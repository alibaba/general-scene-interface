import {
	MeshDataType,
	RenderableMesh,
	MatrBaseDataType,
	// MatrUnlitDataType,
	// MatrPbrDataType,
	// MatrPointDataType,
	// MatrSpriteDataType,
	TextureType,
	GeomDataType,
	Transform3,
	Transform2,
	DISPOSED,
	Int,
} from '@gs.i/schema-scene'
import { Processor, TraverseType } from '@gs.i/processor-base'
import { traverse, flatten } from '@gs.i/utils-traverse'

/**
 * a string representing the structure of a tree.
 * - **only used for comparison**
 * @note comparable only if generated by **the same processor**
 */
type TreeHash = string | Int

/**
 * a string representing a position in a tree.
 * - **only used for comparison**
 * @note comparable only if generated by **the same processor**
 */
type PositionHash = string | Int

/**
 * @note PURE FUNCTIONS. this process will modify the object you input
 * @note CACHED
 */
export class GraphProcessor extends Processor {
	traverseType = TraverseType.None
	type = 'GraphProcessor'
	canEditNode = false
	canEditTree = false

	/**
	 * 这个计数器配合 WeakMap 一起使用作为 **局部**唯一ID，可以避免多个 MatProcessor 实例存在时的撞表问题。
	 *
	 * 所有 id 都从 WeakMap 得到，一个 key 在一个实例中的 id 是唯一的
	 */
	private _counter = 0
	private _ids = new WeakMap<object, Int>()

	getID(o: object): Int {
		let id = this._ids.get(o)
		if (id === undefined) {
			id = this._counter++
			this._ids.set(o, id)
		}

		return id
	}

	hash(root: MeshDataType): TreeHash {
		let result = 'v0:'
		let currParent: MeshDataType | undefined = undefined
		traverse(root, (node, parent) => {
			if (parent === currParent) {
				// same parent
				result += this.getID(node) + ','
			} else {
				// parent change
				currParent = parent
				result += ((parent ? this.getID(parent) : '_') /* root */ as string) + '/'

				result + this.getID(node) + ','
			}
		})

		return result
	}

	hashPosition(node: MeshDataType): PositionHash {
		let result = 'v0:' + this.getID(node) + ','

		let curr: MeshDataType = node
		while (curr.parent) {
			result += this.getID(curr.parent) + ','
		}

		return result
	}

	/**
	 * @note did not sort children, kept the order of adding
	 */
	flatten(root: MeshDataType): MeshDataType[] {
		return flatten(root)
	}
}
